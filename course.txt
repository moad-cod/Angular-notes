
//what is signals and why we used them in angular:
In Angular, signals are a new reactive primitive introduced to simplify and enhance reactivity,
which is essential in modern web applications.
Signals help manage state and reactive updates more efficiently by tracking dependencies and 
automatically triggering updates when data changes.

//why we need a input()in angular:
The @Input() decorator in Angular is crucial for enabling parent-to-child component communication.
It allows a parent component to pass data or values to a child component. This mechanism helps create reusable,
modular components where each component can be configured with different inputs based on the parent component's context.


//why we need a custom events in angular:
Parent-Child Communication (Child-to-Parent Data Flow):
In Angular, data flows down from parent to child components via @Input(). But if achild component needs to send data or notify the parent of an action 
(e.g., a user clicked a button), the data flows upward using custom events.
Custom events allow a child component to notify the parent of something that happened, like user interaction or data updates.
This is achieved using Angularâ€™s @Output() decorator with EventEmitter, which emits a custom event that the parent component listens for.

//What is EventEmitter:
EventEmitter is a class provided by Angular that allows emitting custom events.
It is typically used with @Output() to create custom events in child components.
By using EventEmitter, you can trigger custom events in your child component,
and the parent component can subscribe to and react to those events.

In Angular, the @Injectable() decorator is used to define a service or class that can be injected into
other components or services using Angular's Dependency Injection (DI) system.
 
 